!                                                                                        
!    L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License”        
!    or “3-clause license”)                                                              
!    Please read attached file License_lbfgsb.txt                                               
!                                          
!  ===========   L-BFGS-B (version 3.0.  April 25, 2011  =======================
!  
!       This is a modified version of L-BFGS-B.
!  
!       Major changes are described in the accompanying paper:
!  
!           Jorge Nocedal and Jose Luis Morales, Remark on "Algorithm 778: 
!           L-BFGS-B: Fortran Subroutines for Large-Scale Bound Constrained 
!           Optimization"  (2011). To appear in  ACM Transactions on 
!           Mathematical Software,
!  
!       The paper describes an improvement and a correction to Algorithm 778. 
!       It is shown that the performance of the algorithm can be improved 
!       significantly by making a relatively simple modication to the subspace 
!       minimization phase. The correction concerns an error caused by the use 
!       of routine dpmeps to estimate machine precision. 
!  
!       The total work space **wa** required by the new version is 
!   
!                    2*m*n + 11m*m + 5*n + 8*m 
!  
!       the old version required 
!  
!                    2*m*n + 12m*m + 4*n + 12*m 
!  
!  
!              J. Nocedal  Department of Electrical Engineering and
!                          Computer Science.
!                          Northwestern University. Evanston, IL. USA
!  
!  
!             J.L Morales  Departamento de Matematicas, 
!                          Instituto Tecnologico Autonomo de Mexico
!                          Mexico D.F. Mexico.
!  
!                          March  2011    
!                                 
!  =============================================================================                  
!
! Converted from f77 file in L-BFGS-B into f90 by CS. See License_lbfgsb.txt for
! applicable New BSD license.

!*******************************************************************************                                                                                 
subroutine setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task,       &
    iprint, csave, lsave, isave, dsave)
!*******************************************************************************                                                                                 
! This subroutine partitions the working arrays wa and iwa, and 
!   then uses the limited memory BFGS method to solve the bound
!   constrained optimization problem by calling mainlb.
!   (The direct method will be used in the subspace minimization.)
! 
! n is an integer variable.
!   On entry n is the dimension of the problem.
!   On exit n is unchanged.
! 
! m is an integer variable.
!   On entry m is the maximum number of variable metric corrections
!     used to define the limited memory matrix.
!   On exit m is unchanged.
! 
! x is a double precision array of dimension n.
!   On entry x is an approximation to the solution.
!   On exit x is the current approximation.
! 
! l is a double precision array of dimension n.
!   On entry l is the lower bound on x.
!   On exit l is unchanged.
! 
! u is a double precision array of dimension n.
!   On entry u is the upper bound on x.
!   On exit u is unchanged.
! 
! nbd is an integer array of dimension n.
!   On entry nbd represents the type of bounds imposed on the
!     variables, and must be specified as follows:
!     nbd(i)=0 if x(i) is unbounded,
!            1 if x(i) has only a lower bound,
!            2 if x(i) has both lower and upper bounds, and
!            3 if x(i) has only an upper bound.
!   On exit nbd is unchanged.
! 
! f is a double precision variable.
!   On first entry f is unspecified.
!   On final exit f is the value of the function at x.
! 
! g is a double precision array of dimension n.
!   On first entry g is unspecified.
!   On final exit g is the value of the gradient at x.
! 
! factr is a double precision variable.
!   On entry factr >= 0 is specified by the user.  The iteration
!     will stop when
! 
!     (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
! 
!     where epsmch is the machine precision, which is automatically
!     generated by the code. Typical values for factr: 1.d+12 for
!     low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
!     high accuracy.
!   On exit factr is unchanged.
! 
! pgtol is a double precision variable.
!   On entry pgtol >= 0 is specified by the user.  The iteration
!     will stop when
! 
!             max{|proj g_i | i = 1, ..., n} <= pgtol
! 
!     where pg_i is the ith component of the projected gradient.   
!   On exit pgtol is unchanged.
! 
! wa is a double precision working array of length 
!   (2mmax + 5)nmax + 12mmax^2 + 12mmax.
! 
! iwa is an integer working array of length 3nmax.
! 
! task is a working string of characters of length 60 indicating
!   the current job when entering and quitting this subroutine.
! 
! iprint is an integer variable that must be set by the user.
!   It controls the frequency and type of output generated:
!    iprint<0    no output is generated;
!    iprint=0    print only one line at the last iteration;
!    0<iprint<99 print also f and |proj g| every iprint iterations;
!    iprint=99   print details of every iteration except n-vectors;
!    iprint=100  print also the changes of active set and final x;
!    iprint>100  print details of every iteration including x and g;
!   When iprint > 0, the file iterate.dat will be created to
!                    summarize the iteration.
! 
! csave is a working string of characters of length 60.
! 
! lsave is a logical working array of dimension 4.
!   On exit with 'task' = NEW_X, the following information is 
!                                                         available:
!     If lsave(1) = .true.  then  the initial X has been replaced by
!                                 its projection in the feasible set;
!     If lsave(2) = .true.  then  the problem is constrained;
!     If lsave(3) = .true.  then  each variable has upper and lower
!                                 bounds;
! 
! isave is an integer working array of dimension 44.
!   On exit with 'task' = NEW_X, the following information is 
!                                                         available:
!     isave(22) = the total number of intervals explored in the 
!                     search of Cauchy points;
!     isave(26) = the total number of skipped BFGS updates before 
!                     the current iteration;
!     isave(30) = the number of current iteration;
!     isave(31) = the total number of BFGS updates prior the current
!                     iteration;
!     isave(33) = the number of intervals explored in the search of
!                     Cauchy point in the current iteration;
!     isave(34) = the total number of function and gradient 
!                     evaluations;
!     isave(36) = the number of function value or gradient
!                              evaluations in the current iteration;
!     if isave(37) = 0  then the subspace argmin is within the box;
!     if isave(37) = 1  then the subspace argmin is beyond the box;
!     isave(38) = the number of free variables in the current
!                     iteration;
!     isave(39) = the number of active constraints in the current
!                     iteration;
!     n + 1 - isave(40) = the number of variables leaving the set of
!                       active constraints in the current iteration;
!     isave(41) = the number of variables entering the set of active
!                     constraints in the current iteration.
! 
! dsave is a double precision working array of dimension 29.
!   On exit with 'task' = NEW_X, the following information is
!                                                         available:
!     dsave(1) = current 'theta' in the BFGS matrix;
!     dsave(2) = f(x) in the previous iteration;
!     dsave(3) = factr*epsmch;
!     dsave(4) = 2-norm of the line search direction vector;
!     dsave(5) = the machine precision epsmch generated by the code;
!     dsave(7) = the accumulated time spent on searching for
!                                                     Cauchy points;
!     dsave(8) = the accumulated time spent on
!                                             subspace minimization;
!     dsave(9) = the accumulated time spent on line search;
!     dsave(11) = the slope of the line search function at
!                              the current point of line search;
!     dsave(12) = the maximum relative step length imposed in
!                                                       line search;
!     dsave(13) = the infinity norm of the projected gradient;
!     dsave(14) = the relative step length in the line search;
!     dsave(15) = the slope of the line search function at
!                             the starting point of the line search;
!     dsave(16) = the square of the 2-norm of the line search
!                                                  direction vector.
! 
! Subprograms called:
! 
!   L-BFGS-B Library ... mainlb.    
! 
! 
! References:
! 
!   [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!   memory algorithm for bound constrained optimization'',
!   SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
! 
!   [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!   limited memory FORTRAN code for solving bound constrained
!   optimization problems'', Tech. Report, NAM-11, EECS Department,
!   Northwestern University, 1994.
! 
!   (Postscript files of these papers are available via anonymous
!    ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
! 
!                       *  *  *
! 
! NEOS, November 1994. (Latest revision June 1996.)
! Optimization Technology Center.
! Argonne National Laboratory and Northwestern University.
! Written by
!                    Ciyou Zhu
! in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
! 
! 
implicit none
character*60 :: task, csave
logical :: lsave(4)
integer :: n, m, iprint, nbd(n), iwa(3*n), isave(44)
double precision :: f, factr, pgtol, x(n), l(n), u(n), g(n)
double precision :: wa(2*m*n + 5*n + 11*m*m + 8*m), dsave(29)
integer :: lws,lr,lz,lt,ld,lxp,lwa,lwy,lsy,lss,lwt,lwn,lsnd

if (task .eq. 'START') then
    isave(1)  = m*n
    isave(2)  = m**2
    isave(3)  = 4*m**2
    isave(4)  = 1                      ! ws      m*n
    isave(5)  = isave(4)  + isave(1)   ! wy      m*n
    isave(6)  = isave(5)  + isave(1)   ! wsy     m**2
    isave(7)  = isave(6)  + isave(2)   ! wss     m**2
    isave(8)  = isave(7)  + isave(2)   ! wt      m**2
    isave(9)  = isave(8)  + isave(2)   ! wn      4*m**2
    isave(10) = isave(9)  + isave(3)   ! wsnd    4*m**2
    isave(11) = isave(10) + isave(3)   ! wz      n
    isave(12) = isave(11) + n          ! wr      n
    isave(13) = isave(12) + n          ! wd      n
    isave(14) = isave(13) + n          ! wt      n
    isave(15) = isave(14) + n          ! wxp     n
    isave(16) = isave(15) + n          ! wa      8*m
endif
lws  = isave(4)
lwy  = isave(5)
lsy  = isave(6)
lss  = isave(7)
lwt  = isave(8)
lwn  = isave(9)
lsnd = isave(10)
lz   = isave(11)
lr   = isave(12)
ld   = isave(13)
lt   = isave(14)
lxp  = isave(15)
lwa  = isave(16)

call mainlb(n,m,x,l,u,nbd,f,g,factr,pgtol,wa(lws),wa(lwy),wa(lsy),wa(lss),     &
    wa(lwt),wa(lwn),wa(lsnd),wa(lz),wa(lr),wa(ld),wa(lt),wa(lxp),wa(lwa),      &
    iwa(1),iwa(n+1),iwa(2*n+1),task,iprint,csave,lsave,isave(22),dsave)

end subroutine setulb

!*******************************************************************************                                                                                 
subroutine dpofa(a,lda,n,info)
!*******************************************************************************
! factors a double precision symmetric positive definite matrix.
! 
! dpofa is usually called by dpoco, but it can be called
! directly with a saving in time if  rcond  is not needed.
! (time for dpoco) = (1 + 18/n)*(time for dpofa) .
! 
! on entry
! 
!    a       double precision(lda, n)
!            the symmetric matrix to be factored.  only the
!            diagonal and upper triangle are used.
! 
!    lda     integer
!            the leading dimension of the array  a .
! 
!    n       integer
!            the order of the matrix  a .
! 
! on return
! 
!    a       an upper triangular matrix  r  so that  a = trans(r)*r
!            where  trans(r)  is the transpose.
!            the strict lower triangle is unaltered.
!            if  info .ne. 0 , the factorization is not complete.
! 
!    info    integer
!            = 0  for normal return.
!            = k  signals an error condition.  the leading minor
!                 of order  k  is not positive definite.
! 
! linpack.  this version dated 08/14/78 .
! cleve moler, university of new mexico, argonne national lab.
implicit none
integer lda,n,info
double precision a(lda,*)
double precision ddot,t
double precision s
integer j,jm1,k

do j = 1, n
info = j
s = 0.0d0
jm1 = j - 1
if (jm1 .ge. 1) then
    do k = 1, jm1
        t = a(k,j) - ddot(k-1,a(1,k),1,a(1,j),1)
        t = t/a(k,k)
        a(k,j) = t
        s = s + t*t
    end do
end if
s = a(j,j) - s
if (s .le. 0.0d0) return
a(j,j) = sqrt(s)
end do
info = 0
   
end subroutine dpofa

!*******************************************************************************
subroutine dtrsl(t,ldt,n,b,job,info)
!*******************************************************************************
! solves systems of the form
! 
!               t * x = b
! or
!               trans(t) * x = b
! 
! where t is a triangular matrix of order n. here trans(t)
! denotes the transpose of the matrix t.
! 
! on entry
! 
!     t         double precision(ldt,n)
!               t contains the matrix of the system. the zero
!               elements of the matrix are not referenced, and
!               the corresponding elements of the array can be
!               used to store other information.
! 
!     ldt       integer
!               ldt is the leading dimension of the array t.
! 
!     n         integer
!               n is the order of the system.
! 
!     b         double precision(n).
!               b contains the right hand side of the system.
! 
!     job       integer
!               job specifies what kind of system is to be solved.
!               if job is
! 
!                    00   solve t*x=b, t lower triangular,
!                    01   solve t*x=b, t upper triangular,
!                    10   solve trans(t)*x=b, t lower triangular,
!                    11   solve trans(t)*x=b, t upper triangular.
! 
! on return
! 
!     b         b contains the solution, if info .eq. 0.
!               otherwise b is unaltered.
! 
!     info      integer
!               info contains zero if the system is nonsingular.
!               otherwise info contains the index of
!               the first zero diagonal element of t.
! 
! linpack. this version dated 08/14/78 .
! g. w. stewart, university of maryland, argonne national lab.
implicit none
integer ldt,n,job,info
double precision t(ldt,*),b(*)
double precision ddot,temp
integer c, j, jj

!heck for zero diagonal elements.
do info = 1, n
    if (t(info,info) .eq. 0.0d0) return
end do
info = 0

! determine the task and go to it.
c = 1
if (mod(job,10) .ne. 0) c = 2
if (mod(job,100)/10 .ne. 0) c = c + 2

select case (c)

    case (1)
        ! solve t*x=b for t lower triangular
        b(1) = b(1)/t(1,1)
        if (n .lt. 2) return
        do j = 2, n
           temp = -b(j-1)
           call daxpy(n-j+1,temp,t(j,j-1),1,b(j),1)
           b(j) = b(j)/t(j,j)
        end do
         
    case (2)
        ! solve t*x=b for t upper triangular.
        b(n) = b(n)/t(n,n)
        if (n .lt. 2) return
        do jj = 2, n
            j = n - jj + 1
            temp = -b(j+1)
            call daxpy(j,temp,t(1,j+1),1,b(1),1)
            b(j) = b(j)/t(j,j)
        end do

    case (3)
        ! solve trans(t)*x=b for t lower triangular.
        b(n) = b(n)/t(n,n)
        if (n .lt. 2) return
        do jj = 2, n
            j = n - jj + 1
            b(j) = b(j) - ddot(jj-1,t(j+1,j),1,b(j+1),1)
            b(j) = b(j)/t(j,j)
        end do
        
    case (4)
        ! solve trans(t)*x=b for t upper triangular.
        b(1) = b(1)/t(1,1)
        if (n .lt. 2) return
        do j = 2, n
            b(j) = b(j) - ddot(j-1,t(1,j),1,b(1),1)
            b(j) = b(j)/t(j,j)
        end do
end select

end subroutine dtrsl

