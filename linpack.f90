!
!    L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License”
!    or “3-clause license”)
!    Please read attached file License_lbfgsb.txt
!
!  ===========   L-BFGS-B (version 3.0.  April 25, 2011  =======================
!
!       This is a modified version of L-BFGS-B.
!
!       Major changes are described in the accompanying paper:
!
!           Jorge Nocedal and Jose Luis Morales, Remark on "Algorithm 778:
!           L-BFGS-B: Fortran Subroutines for Large-Scale Bound Constrained
!           Optimization"  (2011). To appear in  ACM Transactions on
!           Mathematical Software,
!
!       The paper describes an improvement and a correction to Algorithm 778.
!       It is shown that the performance of the algorithm can be improved
!       significantly by making a relatively simple modication to the subspace
!       minimization phase. The correction concerns an error caused by the use
!       of routine dpmeps to estimate machine precision.
!
!       The total work space **wa** required by the new version is
!
!                    2*m*n + 11m*m + 5*n + 8*m
!
!       the old version required
!
!                    2*m*n + 12m*m + 4*n + 12*m
!
!
!              J. Nocedal  Department of Electrical Engineering and
!                          Computer Science.
!                          Northwestern University. Evanston, IL. USA
!
!
!             J.L Morales  Departamento de Matematicas,
!                          Instituto Tecnologico Autonomo de Mexico
!                          Mexico D.F. Mexico.
!
!                          March  2011
!
!  =============================================================================
!
! converted from f77 file in L-BFGS-B into f90 by CS. See License_lbfgsb.txt for
! applicable New BSD license.

!*******************************************************************************
subroutine setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task,       &
    iprint, csave, lsave, isave, dsave)
!*******************************************************************************
! This subroutine partitions the working arrays wa and iwa, and
!   then uses the limited memory BFGS method to solve the bound
!   constrained optimization problem by calling mainlb.
!   (The direct method will be used in the subspace minimization.)
!
! n is an integer variable.
!   On entry n is the dimension of the problem.
!   On exit n is unchanged.
!
! m is an integer variable.
!   On entry m is the maximum number of variable metric corrections
!     used to define the limited memory matrix.
!   On exit m is unchanged.
!
! x is a double precision array of dimension n.
!   On entry x is an approximation to the solution.
!   On exit x is the current approximation.
!
! l is a double precision array of dimension n.
!   On entry l is the lower bound on x.
!   On exit l is unchanged.
!
! u is a double precision array of dimension n.
!   On entry u is the upper bound on x.
!   On exit u is unchanged.
!
! nbd is an integer array of dimension n.
!   On entry nbd represents the type of bounds imposed on the
!     variables, and must be specified as follows:
!     nbd(i)=0 if x(i) is unbounded,
!            1 if x(i) has only a lower bound,
!            2 if x(i) has both lower and upper bounds, and
!            3 if x(i) has only an upper bound.
!   On exit nbd is unchanged.
!
! f is a double precision variable.
!   On first entry f is unspecified.
!   On final exit f is the value of the function at x.
!
! g is a double precision array of dimension n.
!   On first entry g is unspecified.
!   On final exit g is the value of the gradient at x.
!
! factr is a double precision variable.
!   On entry factr >= 0 is specified by the user.  The iteration
!     will stop when
!
!     (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!     where epsmch is the machine precision, which is automatically
!     generated by the code. Typical values for factr: 1.d+12 for
!     low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
!     high accuracy.
!   On exit factr is unchanged.
!
! pgtol is a double precision variable.
!   On entry pgtol >= 0 is specified by the user.  The iteration
!     will stop when
!
!             max{|proj g_i | i = 1, ..., n} <= pgtol
!
!     where pg_i is the ith component of the projected gradient.
!   On exit pgtol is unchanged.
!
! wa is a double precision working array of length
!   (2mmax + 5)nmax + 12mmax^2 + 12mmax.
!
! iwa is an integer working array of length 3nmax.
!
! task is a working string of characters of length 60 indicating
!   the current job when entering and quitting this subroutine.
!
! iprint is an integer variable that must be set by the user.
!   It controls the frequency and type of output generated:
!    iprint<0    no output is generated;
!    iprint=0    print only one line at the last iteration;
!    0<iprint<99 print also f and |proj g| every iprint iterations;
!    iprint=99   print details of every iteration except n-vectors;
!    iprint=100  print also the changes of active set and final x;
!    iprint>100  print details of every iteration including x and g;
!   When iprint > 0, the file iterate.dat will be created to
!                    summarize the iteration.
!
!save is a working string of characters of length 60.
!
! lsave is a logical working array of dimension 4.
!   On exit with 'task' = NEW_X, the following information is
!                                                         available:
!     If lsave(1) = .true.  then  the initial X has been replaced by
!                                 its projection in the feasible set;
!     If lsave(2) = .true.  then  the problem is constrained;
!     If lsave(3) = .true.  then  each variable has upper and lower
!                                 bounds;
!
! isave is an integer working array of dimension 44.
!   On exit with 'task' = NEW_X, the following information is
!                                                         available:
!     isave(22) = the total number of intervals explored in the
!                     search of Cauchy points;
!     isave(26) = the total number of skipped BFGS updates before
!                     the current iteration;
!     isave(30) = the number of current iteration;
!     isave(31) = the total number of BFGS updates prior the current
!                     iteration;
!     isave(33) = the number of intervals explored in the search of
!                     Cauchy point in the current iteration;
!     isave(34) = the total number of function and gradient
!                     evaluations;
!     isave(36) = the number of function value or gradient
!                              evaluations in the current iteration;
!     if isave(37) = 0  then the subspace argmin is within the box;
!     if isave(37) = 1  then the subspace argmin is beyond the box;
!     isave(38) = the number of free variables in the current
!                     iteration;
!     isave(39) = the number of active constraints in the current
!                     iteration;
!     n + 1 - isave(40) = the number of variables leaving the set of
!                       active constraints in the current iteration;
!     isave(41) = the number of variables entering the set of active
!                     constraints in the current iteration.
!
! dsave is a double precision working array of dimension 29.
!   On exit with 'task' = NEW_X, the following information is
!                                                         available:
!     dsave(1) = current 'theta' in the BFGS matrix;
!     dsave(2) = f(x) in the previous iteration;
!     dsave(3) = factr*epsmch;
!     dsave(4) = 2-norm of the line search direction vector;
!     dsave(5) = the machine precision epsmch generated by the code;
!     dsave(7) = the accumulated time spent on searching for
!                                                     Cauchy points;
!     dsave(8) = the accumulated time spent on
!                                             subspace minimization;
!     dsave(9) = the accumulated time spent on line search;
!     dsave(11) = the slope of the line search function at
!                              the current point of line search;
!     dsave(12) = the maximum relative step length imposed in
!                                                       line search;
!     dsave(13) = the infinity norm of the projected gradient;
!     dsave(14) = the relative step length in the line search;
!     dsave(15) = the slope of the line search function at
!                             the starting point of the line search;
!     dsave(16) = the square of the 2-norm of the line search
!                                                  direction vector.
!
! Subprograms called:
!
!   L-BFGS-B Library ... mainlb.
!
!
! References:
!
!   [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!   memory algorithm for bound constrained optimization'',
!   SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!   [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!   limited memory FORTRAN code for solving bound constrained
!   optimization problems'', Tech. Report, NAM-11, EECS Department,
!   Northwestern University, 1994.
!
!   (Postscript files of these papers are available via anonymous
!    ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                       *  *  *
!
! NEOS, November 1994. (Latest revision June 1996.)
! Optimization Technology Center.
! Argonne National Laboratory and Northwestern University.
! Written by
!                    Ciyou Zhu
! in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
implicit none
character*60 :: task, csave
logical :: lsave(4)
integer :: n, m, iprint, nbd(n), iwa(3*n), isave(44)
double precision :: f, factr, pgtol, x(n), l(n), u(n), g(n)
double precision :: wa(2*m*n + 5*n + 11*m*m + 8*m), dsave(29)
integer :: lws,lr,lz,lt,ld,lxp,lwa,lwy,lsy,lss,lwt,lwn,lsnd

if (task .eq. 'START') then
    isave(1)  = m*n
    isave(2)  = m**2
    isave(3)  = 4*m**2
    isave(4)  = 1                      ! ws      m*n
    isave(5)  = isave(4)  + isave(1)   ! wy      m*n
    isave(6)  = isave(5)  + isave(1)   ! wsy     m**2
    isave(7)  = isave(6)  + isave(2)   ! wss     m**2
    isave(8)  = isave(7)  + isave(2)   ! wt      m**2
    isave(9)  = isave(8)  + isave(2)   ! wn      4*m**2
    isave(10) = isave(9)  + isave(3)   ! wsnd    4*m**2
    isave(11) = isave(10) + isave(3)   ! wz      n
    isave(12) = isave(11) + n          ! wr      n
    isave(13) = isave(12) + n          ! wd      n
    isave(14) = isave(13) + n          ! wt      n
    isave(15) = isave(14) + n          ! wxp     n
    isave(16) = isave(15) + n          ! wa      8*m
endif
lws  = isave(4)
lwy  = isave(5)
lsy  = isave(6)
lss  = isave(7)
lwt  = isave(8)
lwn  = isave(9)
lsnd = isave(10)
lz   = isave(11)
lr   = isave(12)
ld   = isave(13)
lt   = isave(14)
lxp  = isave(15)
lwa  = isave(16)

call mainlb(n,m,x,l,u,nbd,f,g,factr,pgtol,wa(lws),wa(lwy),wa(lsy),wa(lss),     &
    wa(lwt),wa(lwn),wa(lsnd),wa(lz),wa(lr),wa(ld),wa(lt),wa(lxp),wa(lwa),      &
    iwa(1),iwa(n+1),iwa(2*n+1),task,iprint,csave,lsave,isave(22),dsave)

end subroutine setulb

!*******************************************************************************
subroutine dpofa(a,lda,n,info)
!*******************************************************************************
! factors a double precision symmetric positive definite matrix.
!
! dpofa is usually called by dpoco, but it can be called
! directly with a saving in time if  rcond  is not needed.
! (time for dpoco) = (1 + 18/n)*(time for dpofa) .
!
! on entry
!
!    a       double precision(lda, n)
!            the symmetric matrix to be factored.  only the
!            diagonal and upper triangle are used.
!
!    lda     integer
!            the leading dimension of the array  a .
!
!    n       integer
!            the order of the matrix  a .
!
! on return
!
!    a       an upper triangular matrix  r  so that  a = trans(r)*r
!            where  trans(r)  is the transpose.
!            the strict lower triangle is unaltered.
!            if  info .ne. 0 , the factorization is not complete.
!
!    info    integer
!            = 0  for normal return.
!            = k  signals an error condition.  the leading minor
!                 of order  k  is not positive definite.
!
! linpack.  this version dated 08/14/78 .
!leve moler, university of new mexico, argonne national lab.
implicit none
integer lda,n,info
double precision a(lda,*)
double precision ddot,t
double precision s
integer j,jm1,k

do j = 1, n
info = j
s = 0.0d0
jm1 = j - 1
if (jm1 .ge. 1) then
    do k = 1, jm1
        t = a(k,j) - ddot(k-1,a(1,k),1,a(1,j),1)
        t = t/a(k,k)
        a(k,j) = t
        s = s + t*t
    end do
end if
s = a(j,j) - s
if (s .le. 0.0d0) return
a(j,j) = sqrt(s)
end do
info = 0

end subroutine dpofa

!*******************************************************************************
subroutine dtrsl(t,ldt,n,b,job,info)
!*******************************************************************************
! solves systems of the form
!
!               t * x = b
! or
!               trans(t) * x = b
!
! where t is a triangular matrix of order n. here trans(t)
! denotes the transpose of the matrix t.
!
! on entry
!
!     t         double precision(ldt,n)
!               t contains the matrix of the system. the zero
!               elements of the matrix are not referenced, and
!               the corresponding elements of the array can be
!               used to store other information.
!
!     ldt       integer
!               ldt is the leading dimension of the array t.
!
!     n         integer
!               n is the order of the system.
!
!     b         double precision(n).
!               b contains the right hand side of the system.
!
!     job       integer
!               job specifies what kind of system is to be solved.
!               if job is
!
!                    00   solve t*x=b, t lower triangular,
!                    01   solve t*x=b, t upper triangular,
!                    10   solve trans(t)*x=b, t lower triangular,
!                    11   solve trans(t)*x=b, t upper triangular.
!
! on return
!
!     b         b contains the solution, if info .eq. 0.
!               otherwise b is unaltered.
!
!     info      integer
!               info contains zero if the system is nonsingular.
!               otherwise info contains the index of
!               the first zero diagonal element of t.
!
! linpack. this version dated 08/14/78 .
! g. w. stewart, university of maryland, argonne national lab.
implicit none
integer ldt,n,job,info
double precision t(ldt,*),b(*)
double precision ddot,temp
integer c, j, jj

!heck for zero diagonal elements.
do info = 1, n
    if (t(info,info) .eq. 0.0d0) return
end do
info = 0

! determine the task and go to it.
c = 1
if (mod(job,10) .ne. 0) c = 2
if (mod(job,100)/10 .ne. 0) c = c + 2

select case (c)

    case (1)
        ! solve t*x=b for t lower triangular
        b(1) = b(1)/t(1,1)
        if (n .lt. 2) return
        do j = 2, n
           temp = -b(j-1)
           call daxpy(n-j+1,temp,t(j,j-1),1,b(j),1)
           b(j) = b(j)/t(j,j)
        end do

    case (2)
        ! solve t*x=b for t upper triangular.
        b(n) = b(n)/t(n,n)
        if (n .lt. 2) return
        do jj = 2, n
            j = n - jj + 1
            temp = -b(j+1)
            call daxpy(j,temp,t(1,j+1),1,b(1),1)
            b(j) = b(j)/t(j,j)
        end do

    case (3)
        ! solve trans(t)*x=b for t lower triangular.
        b(n) = b(n)/t(n,n)
        if (n .lt. 2) return
        do jj = 2, n
            j = n - jj + 1
            b(j) = b(j) - ddot(jj-1,t(j+1,j),1,b(j+1),1)
            b(j) = b(j)/t(j,j)
        end do

    case (4)
        ! solve trans(t)*x=b for t upper triangular.
        b(1) = b(1)/t(1,1)
        if (n .lt. 2) return
        do j = 2, n
            b(j) = b(j) - ddot(j-1,t(1,j),1,b(1),1)
            b(j) = b(j)/t(j,j)
        end do
end select

end subroutine dtrsl

!*******************************************************************************
subroutine mainlb(n, m, x, l, u, nbd, f, g, factr, pgtol, ws, wy, sy, ss, wt,  &
    wn, snd, z, r, d, t, xp, wa, index, iwhere, indx2, task, iprint, csave,    &
    lsave, isave, dsave)
!*******************************************************************************
! This subroutine solves bound constrained optimization problems by
! using the compact formula of the limited memory BFGS updates.
!
! n is an integer variable.
! On entry n is the number of variables.
! On exit n is unchanged.
!
! m is an integer variable.
! On entry m is the maximum number of variable metric
! corrections allowed in the limited memory matrix.
! On exit m is unchanged.
!
! x is a double precision array of dimension n.
! On entry x is an approximation to the solution.
! On exit x is the current approximation.
!
! l is a double precision array of dimension n.
! On entry l is the lower bound of x.
! On exit l is unchanged.
!
! u is a double precision array of dimension n.
! On entry u is the upper bound of x.
! On exit u is unchanged.
!
! nbd is an integer array of dimension n.
! On entry nbd represents the type of bounds imposed on the
! variables, and must be specified as follows:
! nbd(i)=0 if x(i) is unbounded,
! 1 if x(i) has only a lower bound,
! 2 if x(i) has both lower and upper bounds,
! 3 if x(i) has only an upper bound.
! On exit nbd is unchanged.
!
! f is a double precision variable.
! On first entry f is unspecified.
! On final exit f is the value of the function at x.
!
! g is a double precision array of dimension n.
! On first entry g is unspecified.
! On final exit g is the value of the gradient at x.
!
! factr is a double precision variable.
! On entry factr >= 0 is specified by the user.  The iteration
! will stop when
!
! (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
! where epsmch is the machine precision, which is automatically
! generated by the code.
! On exit factr is unchanged.
!
! pgtol is a double precision variable.
! On entry pgtol >= 0 is specified by the user.  The iteration
! will stop when
!
! max{|proj g_i | i = 1, ..., n} <= pgtol
!
! where pg_i is the ith component of the projected gradient.
! On exit pgtol is unchanged.
!
! ws, wy, sy, and wt are double precision working arrays used to
! store the following information defining the limited memory
! BFGS matrix:
! ws, of dimension n x m, stores S, the matrix of s-vectors;
! wy, of dimension n x m, stores Y, the matrix of y-vectors;
! sy, of dimension m x m, stores S'Y;
! ss, of dimension m x m, stores S'S;
! yy, of dimension m x m, stores Y'Y;
! wt, of dimension m x m, stores the Cholesky factorization
! of (theta*S'S+LD^(-1)L'); see eq.
! (2.26) in [3].
!
! wn is a double precision working array of dimension 2m x 2m
! used to store the LEL^T factorization of the indefinite matrix
! K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
! [L_a -R_z           theta*S'AA'S ]
!
! where     E = [-I  0]
! [ 0  I]
!
! snd is a double precision working array of dimension 2m x 2m
! used to store the lower triangular part of
! N = [Y' ZZ'Y   L_a'+R_z']
! [L_a +R_z  S'AA'S   ]
!
! z(n),r(n),d(n),t(n), xp(n),wa(8*m) are double precision working arrays.
! z  is used at different times to store the Cauchy point and
! the Newton point.
! xp is used to safeguard the projected Newton direction
!
! sg(m),sgo(m),yg(m),ygo(m) are double precision working arrays.
!
! index is an integer working array of dimension n.
! In subroutine freev, index is used to store the free and fixed
! variables at the Generalized Cauchy Point (GCP).
!
! iwhere is an integer working array of dimension n used to record
! the status of the vector x for GCP computation.
! iwhere(i)=0 or -3 if x(i) is free and has bounds,
! 1       if x(i) is fixed at l(i), and l(i) .ne. u(i)
! 2       if x(i) is fixed at u(i), and u(i) .ne. l(i)
! 3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
! -1       if x(i) is always free, i.e., no bounds on it.
!
! indx2 is an integer working array of dimension n.
! Within subroutine cauchy, indx2 corresponds to the array iorder.
! In subroutine freev, a list of variables entering and leaving
! the free set is stored in indx2, and it is passed on to
! subroutine formk with this information.
!
! task is a working string of characters of length 60 indicating
! the current job when entering and leaving this subroutine.
!
! iprint is an INTEGER variable that must be set by the user.
! It controls the frequency and type of output generated:
! iprint<0    no output is generated;
! iprint=0    print only one line at the last iteration;
! 0<iprint<99 print also f and |proj g| every iprint iterations;
! iprint=99   print details of every iteration except n-vectors;
! iprint=100  print also the changes of active set and final x;
! iprint>100  print details of every iteration including x and g;
! When iprint > 0, the file iterate.dat will be created to
! summarize the iteration.
!
! csave is a working string of characters of length 60.
!
! lsave is a logical working array of dimension 4.
!
! isave is an integer working array of dimension 23.
!
! dsave is a double precision working array of dimension 29.
!
!
! Subprograms called
!
! L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk,
!
! errclb, prn1lb, prn2lb, prn3lb, active, projgr,
!
! freev, cmprlb, matupd, formt.
!
! Minpack2 Library ... timer
!
! Linpack Library ... dcopy, ddot.
!
!
! References:
!
! [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
! memory algorithm for bound constrained optimization'',
! SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
! [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
! Subroutines for Large Scale Bound Constrained Optimization''
! Tech. Report, NAM-11, EECS Department, Northwestern University,
! 1994.
!
! [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of
! Quasi-Newton Matrices and their use in Limited Memory Methods'',
! Mathematical Programming 63 (1994), no. 4, pp. 129-156.
!
! (Postscript files of these papers are available via anonymous
! ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
! *  *  *
!
! NEOS, November 1994. (Latest revision June 1996.)
! Optimization Technology Center.
! Argonne National Laboratory and Northwestern University.
! Written by
! Ciyou Zhu
! in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
implicit none
character*60 :: task, csave
logical :: lsave(4)
integer :: n, m, iprint, nbd(n), index(n), iwhere(n), indx2(n), isave(23)
double precision :: f, factr, pgtol, x(n), l(n), u(n), g(n), z(n), r(n)
double precision :: d(n), t(n), xp(n), wa(8*m), ws(n, m), wy(n, m), sy(m, m)
double precision :: ss(m, m), wt(m, m), wn(2*m, 2*m), snd(2*m, 2*m), dsave(29)
logical :: prjctd,cnstnd,boxed,updatd,wrk
character*3 :: word
integer :: i,k,nintol,itfile,iback,nskip, head,col,iter,itail,iupdat
integer :: nseg,nfgv,info,ifun,iword,nfree,nact,ileave,nenter
double precision :: theta,fold,ddot,dr,rr,tol,xstep,sbgnrm,ddum,dnorm,dtd
double precision :: epsmch,cpu1,cpu2,cachyt,sbtime,lnscht,time1,time2
double precision :: gd,gdold,stp,stpmx,time
double precision :: one,zero
parameter (one=1.0d0,zero=0.0d0)
integer :: taskn
logical :: call_prn3lb, skip_loop

call_prn3lb = .true.
skip_loop = .false.

if (task .eq. 'START') then
    epsmch = epsilon(one)
    call cpu_time(time1)
    ! Initialize counters and scalars when task='START'.
    ! for the limited memory BFGS matrices:
    col    = 0
    head   = 1
    theta  = one
    iupdat = 0
    updatd = .false.
    iback  = 0
    itail  = 0
    iword  = 0
    nact   = 0
    ileave = 0
    nenter = 0
    fold   = zero
    dnorm  = zero
    cpu1   = zero
    gd     = zero
    stpmx  = zero
    sbgnrm = zero
    stp    = zero
    gdold  = zero
    dtd    = zero

    ! for operation counts:
    iter   = 0
    nfgv   = 0
    nseg   = 0
    nintol = 0
    nskip  = 0
    nfree  = n
    ifun   = 0
    ! for stopping tolerance:
    tol = factr*epsmch

    ! for measuring running time:
    cachyt = 0
    sbtime = 0
    lnscht = 0

    ! 'word' records the status of subspace solutions.
    word = '---'

    ! 'info' records the termination information.
    info = 0

    itfile = 8
    if (iprint .ge. 1) then
        ! open a summary file 'iterate.dat'
        open (8, file = 'iterate.dat', status = 'unknown')
    endif

    !heck the input arguments for errors.
    call errclb(n,m,factr,l,u,nbd,task,info,k)
    if (task(1:5) .eq. 'ERROR') then
        call prn3lb(n,x,f,task,iprint,info,itfile,iter,nfgv,nintol,nskip,nact, &
            sbgnrm,zero,nseg,word,iback,stp,xstep,k,cachyt,sbtime,lnscht)
        return
    endif

    call prn1lb(n,m,l,u,x,iprint,itfile,epsmch)

    ! Initialize iwhere & project x onto the feasible set.
    call active(n,l,u,nbd,x,iwhere,iprint,prjctd,cnstnd,boxed)

    ! The end of the initialization.
else
    ! restore local variables.
    prjctd = lsave(1)
    cnstnd = lsave(2)
    boxed  = lsave(3)
    updatd = lsave(4)

    nintol = isave(1)
    itfile = isave(3)
    iback  = isave(4)
    nskip  = isave(5)
    head   = isave(6)
    col    = isave(7)
    itail  = isave(8)
    iter   = isave(9)
    iupdat = isave(10)
    nseg   = isave(12)
    nfgv   = isave(13)
    info   = isave(14)
    ifun   = isave(15)
    iword  = isave(16)
    nfree  = isave(17)
    nact   = isave(18)
    ileave = isave(19)
    nenter = isave(20)

    theta  = dsave(1)
    fold   = dsave(2)
    tol    = dsave(3)
    dnorm  = dsave(4)
    epsmch = dsave(5)
    cpu1   = dsave(6)
    cachyt = dsave(7)
    sbtime = dsave(8)
    lnscht = dsave(9)
    time1  = dsave(10)
    gd     = dsave(11)
    stpmx  = dsave(12)
    sbgnrm = dsave(13)
    stp    = dsave(14)
    gdold  = dsave(15)
    dtd    = dsave(16)
endif

taskn = 1

! After returning from the driver go to the point where execution
! is to resume.
if (task(1:5) .eq. 'FG_LN') then
    taskn = 2
else if (task(1:5) .eq. 'NEW_X') then
    taskn = 3
else if (task(1:5) .ne. 'FG_ST') then
    if (task(1:4) .eq. 'STOP') then
        if (task(7:9) .eq. 'CPU') then
            ! restore the previous iterate.
            call dcopy(n,t,1,x,1)
            call dcopy(n,r,1,g,1)
            f = fold
        endif
        skip_loop = .true.
    else
        ! compute f0 and g0.
        task = 'FG_START'
        ! return to the driver to calculate f and g; reenter at 111.
        skip_loop = .true.
        call_prn3lb = .false.
    endif
end if

if (.not.skip_loop .and. taskn .eq. 1) then
    ! location 111
    nfgv = 1

    ! Compute the infinity norm of the (-) projected gradient.
    call projgr(n,l,u,nbd,x,g,sbgnrm)

    if (iprint .ge. 1) then
        write (6,"(/,'At iterate',i5,4x,'f= ',1p,d12.5,4x,'|proj g|=          &
            &',1p,d12.5)") iter,f,sbgnrm
        write (itfile,"(2(1x,i4),5x,'-',5x,'-',3x,'-',5x,'-',5x,'-',8x,'-',3x,&
            &1p,2(1x,d10.3))") iter,nfgv,sbgnrm,f
    endif
    if (sbgnrm .le. pgtol) then
        ! terminate the algorithm.
        task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
        skip_loop = .true.
    endif
end if

! ----------------- the beginning of the loop --------------------------
do while (.not. skip_loop)
    if (taskn .le. 1) then
        if (iprint .ge. 99) write (6,"(//,'ITERATION ',i5)") iter + 1
        iword = -1

        if (.not. cnstnd .and. col .gt. 0) then
            ! skip the search for GCP.
            call dcopy(n,x,1,z,1)
            wrk = updatd
            nseg = 0
        else

            ! Compute the Generalized Cauchy Point (GCP).
            call cpu_time(cpu1)
            call cauchy(n,x,l,u,nbd,g,indx2,iwhere,t,d,z,m,wy,ws,sy,wt,theta,col,head, &
                wa(1),wa(2*m+1),wa(4*m+1),wa(6*m+1),nseg,iprint,sbgnrm,info,epsmch)
            if (info .ne. 0) then
                ! singular triangular system detected; refresh the lbfgs memory.
                if(iprint .ge. 1) then
                    write (6, *) " Singular triangular system detected;"
                    write (6, *) "   refresh the lbfgs memory and restart the iteration."
                end if
                info   = 0
                col    = 0
                head   = 1
                theta  = one
                iupdat = 0
                updatd = .false.
                call cpu_time(cpu2)
                cachyt = cachyt + cpu2 - cpu1
                cycle
            endif
            call cpu_time(cpu2)
            cachyt = cachyt + cpu2 - cpu1
            nintol = nintol + nseg

            ! Count the entering and leaving variables for iter > 0;
            ! find the index set of free and active variables at the GCP.
            call freev(n,nfree,index,nenter,ileave,indx2,iwhere,wrk,updatd,cnstnd,iprint,iter)
            nact = n - nfree
        end if

        ! If there are no free variables or B=theta*I, then
        ! skip the subspace minimization.
        if (.not.(nfree .eq. 0 .or. col .eq. 0)) then
            ! Subspace minimization.
            call cpu_time(cpu1)

            ! Form  the LEL^T factorization of the indefinite
            ! matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
            ! [L_a -R_z           theta*S'AA'S ]
            ! where     E = [-I  0]
            ! [ 0  I]
            if (wrk) call formk(n,nfree,index,nenter,ileave,indx2,iupdat,              &
                updatd,wn,snd,m,ws,wy,sy,theta,col,head,info)
            if (info .ne. 0) then
                ! nonpositive definiteness in Cholesky factorization;
                ! refresh the lbfgs memory and restart the iteration.
                if(iprint .ge. 1) then
                    write (6, *) " Nonpositive definiteness in Cholesky factorization in formk"
                    write (6, *) "   refresh the lbfgs memory and restart the iteration."
                end if
                info   = 0
                col    = 0
                head   = 1
                theta  = one
                iupdat = 0
                updatd = .false.
                call cpu_time(cpu2)
                sbtime = sbtime + cpu2 - cpu1
                cycle
            endif

            ! compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x)
            !   from 'cauchy').
            call cmprlb(n,m,x,g,ws,wy,sy,wt,z,r,wa,index,theta,col,head,nfree,cnstnd,info)
            if (info .eq. 0) then
                ! call the direct method.
                call subsm( n, m, nfree, index, l, u, nbd, z, r, xp, ws, wy,&
                    theta, x, g, col, head, iword, wa, wn, iprint, info)
            end if

            if (info .ne. 0) then
                ! singular triangular system detected;
                ! refresh the lbfgs memory and restart the iteration.
                if(iprint .ge. 1) then
                    write(6, *) " Singular triangular system detected; "
                    write(6, *) "   refresh the lbfgs memory and restart the iteration."
                end if
                info   = 0
                col    = 0
                head   = 1
                theta  = one
                iupdat = 0
                updatd = .false.
                call cpu_time(cpu2)
                sbtime = sbtime + cpu2 - cpu1
                cycle
            endif

            call cpu_time(cpu2)
            sbtime = sbtime + cpu2 - cpu1
        end if

        ! Line search and optimality tests.

        ! Generate the search direction d:=z-x.
        do i = 1, n
            d(i) = z(i) - x(i)
        end do
        call cpu_time(cpu1)
    endif
    ! location 666
    if (taskn .le. 2) then
        taskn = 1
        call lnsrlb(n,l,u,nbd,x,f,fold,gd,gdold,g,d,r,t,z,stp,dnorm,&
            dtd,xstep,stpmx,iter,ifun,iback,nfgv,info,task,&
            boxed,cnstnd,csave,isave(22),dsave(17))

        if (info .ne. 0 .or. iback .ge. 20) then
            ! restore the previous iterate.
            call dcopy(n,t,1,x,1)
            call dcopy(n,r,1,g,1)
            f = fold
            if (col .eq. 0) then
                ! abnormal termination.
                if (info .eq. 0) then
                    info = -9
                    ! restore the actual number of f and g evaluations etc.
                    nfgv = nfgv - 1
                    ifun = ifun - 1
                    iback = iback - 1
                endif
                task = 'ABNORMAL_TERMINATION_IN_LNSRCH'
                iter = iter + 1
                exit
            else
                ! refresh the lbfgs memory and restart the iteration.
                if(iprint .ge. 1) then
                    write (6, *)" Bad direction in the line search;"
                    write (6, *)"   refresh the lbfgs memory and restart the iteration."
                end if
                if (info .eq. 0) nfgv = nfgv - 1
                info   = 0
                col    = 0
                head   = 1
                theta  = one
                iupdat = 0
                updatd = .false.
                task   = 'RESTART_FROM_LNSRCH'
                call cpu_time(cpu2)
                lnscht = lnscht + cpu2 - cpu1
                cycle
            endif
        else if (task(1:5) .eq. 'FG_LN') then
            ! return to the driver for calculating f and g; reenter at 666.
            call_prn3lb = .false.
            exit
        else
            ! calculate and print out the quantities related to the new X.
            call cpu_time(cpu2)
            lnscht = lnscht + cpu2 - cpu1
            iter = iter + 1

            ! Compute the infinity norm of the projected (-)gradient.
            call projgr(n,l,u,nbd,x,g,sbgnrm)

            ! Print iteration information.
            call prn2lb(n,x,f,g,iprint,itfile,iter,nfgv,nact,&
                sbgnrm,nseg,word,iword,iback,stp,xstep)
            call_prn3lb = .false.
            exit
        endif
    endif
    ! location 777
    taskn = 1

    ! Test for termination.
    if (sbgnrm .le. pgtol) then
        ! terminate the algorithm.
        task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
        exit
    endif

    ddum = max(abs(fold), abs(f), one)
    if ((fold - f) .le. tol*ddum) then
        ! terminate the algorithm.
        task = 'CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH'
        if (iback .ge. 10) info = -5
        ! i.e., to issue a warning if iback>10 in the line search.
        exit
    endif

    ! Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's.

    do i = 1, n
        r(i) = g(i) - r(i)
    end do
    rr = ddot(n,r,1,r,1)
    if (stp .eq. one) then
        dr = gd - gdold
        ddum = -gdold
    else
        dr = (gd - gdold)*stp
        call dscal(n,stp,d,1)
        ddum = -gdold*stp
    endif

    if (dr .le. epsmch*ddum) then
        ! skip the L-BFGS update.
        nskip = nskip + 1
        updatd = .false.
        if (iprint .ge. 1) then
            write (6,"('  ys=',1p,e10.3,'  -gs=',1p,e10.3,' BFGS update SKIPPED')") &
                dr, ddum
        end if
        cycle
    endif

    ! Update the L-BFGS matrix.
    updatd = .true.
    iupdat = iupdat + 1

    ! Update matrices WS and WY and form the middle matrix in B.
    call matupd(n,m,ws,wy,sy,ss,d,r,itail,iupdat,col,head,theta,rr,dr,stp,dtd)

    ! Form the upper half of the pds T = theta*SS + L*D^(-1)*L';
    ! Store T in the upper triangular of the array wt;
    ! Cholesky factorize T to J*J' with
    ! J' stored in the upper triangular of wt.
    call formt(m,wt,sy,ss,col,theta,info)

    if (info .ne. 0) then
        ! nonpositive definiteness in Cholesky factorization;
        ! refresh the lbfgs memory and restart the iteration.
        if(iprint .ge. 1) then
            write(6, *) " Nonpositive definiteness in Cholesky factorization in formt;"
            write(6, *) "   refresh the lbfgs memory and restart the iteration."
            end if
            info = 0
            col = 0
            head = 1
            theta = one
            iupdat = 0
            updatd = .false.
        cycle
    endif
    ! Now the inverse of the middle matrix in B is
    !
    ! [  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ]
    ! [ -L*D^(-1/2)   J ] [  0        J'          ]
end do
! -------------------- the end of the loop -----------------------------

if (call_prn3lb) then
    call cpu_time(time2)
    time = time2 - time1
    call prn3lb(n,x,f,task,iprint,info,itfile,iter,nfgv,nintol,nskip,nact,sbgnrm,  &
                 time,nseg,word,iback,stp,xstep,k,cachyt,sbtime,lnscht)
end if

! Save local variables.
lsave(1)  = prjctd
lsave(2)  = cnstnd
lsave(3)  = boxed
lsave(4)  = updatd

isave(1)  = nintol
isave(3)  = itfile
isave(4)  = iback
isave(5)  = nskip
isave(6)  = head
isave(7)  = col
isave(8)  = itail
isave(9)  = iter
isave(10) = iupdat
isave(12) = nseg
isave(13) = nfgv
isave(14) = info
isave(15) = ifun
isave(16) = iword
isave(17) = nfree
isave(18) = nact
isave(19) = ileave
isave(20) = nenter

dsave(1)  = theta
dsave(2)  = fold
dsave(3)  = tol
dsave(4)  = dnorm
dsave(5)  = epsmch
dsave(6)  = cpu1
dsave(7)  = cachyt
dsave(8)  = sbtime
dsave(9)  = lnscht
dsave(10) = time1
dsave(11) = gd
dsave(12) = stpmx
dsave(13) = sbgnrm
dsave(14) = stp
dsave(15) = gdold
dsave(16) = dtd

end subroutine mainlb

!*******************************************************************************
subroutine active(n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed)
!*******************************************************************************
! This subroutine initializes iwhere and projects the initial x to
! the feasible set if necessary.
!
! iwhere is an integer array of dimension n.
!   On entry iwhere is unspecified.
!   On exit iwhere(i)=-1  if x(i) has no bounds
!                     3   if l(i)=u(i)
!                     0   otherwise.
!   In cauchy, iwhere is given finer gradations.
!
!
!                       *  *  *
!
! NEOS, November 1994. (Latest revision June 1996.)
! Optimization Technology Center.
! Argonne National Laboratory and Northwestern University.
! Written by
!                    Ciyou Zhu
! in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
implicit none
logical          prjctd, cnstnd, boxed
integer          n, iprint, nbd(n), iwhere(n)
double precision x(n), l(n), u(n)
integer          nbdd,i
double precision zero
parameter        (zero=0.0d0)
! Initialize nbdd, prjctd, cnstnd and boxed.
nbdd = 0
prjctd = .false.
cnstnd = .false.
boxed = .true.

! Project the initial x to the easible set if necessary.
do i = 1, n
   if (nbd(i) .gt. 0) then
      if (nbd(i) .le. 2 .and. x(i) .le. l(i)) then
         if (x(i) .lt. l(i)) then
            prjctd = .true.
            x(i) = l(i)
         endif
         nbdd = nbdd + 1
      else if (nbd(i) .ge. 2 .and. x(i) .ge. u(i)) then
         if (x(i) .gt. u(i)) then
            prjctd = .true.
            x(i) = u(i)
         endif
         nbdd = nbdd + 1
      endif
   endif
end do

! Initialize iwhere and assign values to cnstnd and boxed.
do i = 1, n
    if (nbd(i) .ne. 2) boxed = .false.
    if (nbd(i) .eq. 0) then
        ! this variable is always free
        iwhere(i) = -1
        ! otherwise set x(i)=mid(x(i), u(i), l(i)).
   else
       cnstnd = .true.
       if (nbd(i) .eq. 2 .and. u(i) - l(i) .le. zero) then
           ! this variable is always fixed
           iwhere(i) = 3
       else
           iwhere(i) = 0
       endif
    endif
end do

if (iprint .ge. 0) then
    if (prjctd) write (6,*) "The initial X is infeasible.  Restart with its projection."
    if (.not. cnstnd) write (6,*) "This problem is unconstrained."
endif

if (iprint .gt. 0) then
    write (6,"(/,'At X0 ',i9,' variables are exactly at the bounds')") nbdd
end if

end subroutine active
